<!--
 * @Author: skypeee
 * @LastEditors: skypeee
 * @Description: file content
 * @Date: 2019-08-29 10:27:43
 -->
# 其他算法

## 判断链表是否有环

### 方法一

- 首先从头节点开始，依次遍历单链表中的每一个节点

- 从头检查新节点之前的所有节点

- 用新节点和此之前所有节点作比较，如果发现相同则说明有环

- 假设节点数为n，则时间复杂度为O(n²)，空间复杂度为O(1)

### 方法二

- 创建于给以节点Id为Key的HashSet集合，用来存储曾经遍历过的节点

- 从头结点开始，依次遍历单链表中每一个节点

  - 每遍历一个节点，都用新节点与HashSet集合中存储的节点进行比较，如果有相同则有环，不存在则插入HashSet

- 假设节点数为n，时间复杂度为O(n)，空间复杂度为O(n)

### 方法三

- 创建两个指针指向头节点

- 进行循环，指针P1每次向后移动1个节点，P2每次向后移动2个节点

- 比较两个节点是否相同，如果相同则有环，否则继续循环

- 假设节点数为n，时间复杂度为O(n)，空间复杂度为O(1)

- 环长 = 每一次速度差 * 前进次数 = 前进次数

## 最小栈的实现

- 实现一个栈，该栈带有出栈（pop）、入栈（push）、取最小元素（getMin）3个方法。要保证这三分方法时间复杂度都是O(1)

### 思路

- 原有的栈为栈A，创建一个“备胎”栈，栈B

- 当第一个元素进入栈A时，让此元素也进入栈B，这个元素时当前栈A的最小值

- 每次新元素进入栈A时，先与当前最小值比较，如果小于最小值，则进入栈B，则栈B的栈顶元素即为栈A的最小值

- 每当有元素出战，如果出栈元素是栈A的最小值，栈B栈顶元素也出栈，此时b栈新栈顶元素也成为了栈A的最小值（备胎转正）

- 获取最小值元素getMin就是获取栈B的栈顶元素

- 进栈、出栈、活取最小值时间复杂度都是O(1)，最坏空间复杂度是O(n)

## 最大公约数

### 辗转相除法（欧几里得算法）

- 两个正整数a和b（a>b），他们的最大公约数等于a除以b的余数c和b之间的最大公约数

### 更相减损法

- 两个正整数a和b（a>b），他们的最大公约数等于a-b的差值c和较小数b的最大公约数

### 结合

- 把辗转相除法与更相减损法的优势结合起来，在更相减损法的基础上使用移位运算

  - 获得最大公约数的方法getGreatestCommomDivisor简写为gcd

- 当a和b均为偶数时，gcd(a,b) = 2 *gcd(a/2, b/2) = 2* gcd(a>>1, b>>1)

- 当a为偶数，b为奇数时，gcd(a,b) = gcd(a/2,b) = gcd(a>>1,b)

- 当a为奇数时，b为偶数，gcd(a,b) = gcd(a,b/2) = gcd(a,b>>1)

- 当a和b均为奇数时，先利用更相减损法运算一次，gcd(a,b) = gcd(b,a-b)，此时a-b必为偶数，然后又可以继续进行移位运算

### 复杂度

- 暴力枚举法：时间复杂度时O(min(a,b))

- 辗转相除法：时间复杂度近似为O(log(max(a,b))),但是取模运算性能较差

- 更相减损法：避免了取模运算，但算法不太稳定，最坏时间复杂度为O(max(a,b))

- 更相减损法和移位相结合：避免了取模运算，算法稳定，时间复杂度为O(log(max(a,b)))

## 判断一个数是否为2的整数次幂

### 思路

- 是2的整数次幂的特点为该数转化为二进制，只有最高位是1，其余位都是0

- 因此该数字减1，所有的位数都为1

- 0和1按位运算的结果是0，饭十2的整数次幂和他本身减一的结果按位运算结果必然是0

## 无序数组排序后的最大相邻数

- 有一个无序整型数组，如何求出该数组排序后的任意两个相邻元素的最大差值（不进行排序）

### 解题思路1

- 利用计数排序的思想，先求出原数组的最大值与最小值的区间长度k=max-min+1以及位偏移量d=min
- 创建一个长度为k的新数组Array
- 遍历原数组，每遍历一个元素，就把新数组Array对应下标的值+1
- 遍历新数组，统计出Array中最大连续出现0的次数，即为相邻元素的最大差值

### 解题思路2

- 利用桶排序的思想，求出原数组长度n，分为n个桶，每个桶代表一个区间，区间跨度为（max/min）/（n-1）
- 遍历原数组，把原数组的元素一一插入对应的桶中，记录每个桶的最大值和最小值
- 遍历所有的桶，统计出每一个桶的最大值，和这个桶右侧非空桶的最小值的查，数值最大的查即为原数组排序后的相邻最大差值
- 时间复杂度稳定，为O(n)

## 如何用栈来实现队列

- 用栈来模拟，入队，出队

### 解题思路

- 创建两个栈一个栈最为队列的入口，负责插入新数据，一个栈作为队列的出口，移除老元素
- 入队时，每一个元素都压入栈A
- 出队时，将栈A中所有元素一一压入栈B，再通过栈B进行出栈
- 再次入队时，将栈B的元素一一压入栈A中，再通过栈A进行入队

## 寻找全排列的下一个数

### 题目

- 给出一个正整数，找出这个正整数所有数字全排列的下一个数
- 如果输入12345，返回12354
- 如果输入12354，返回12435
- 如果输入12435，返回12453

### 解题思路（字典序算法）

- 和原数接近，尽量保持高位不变，低位在最小范围内变换顺序
- 变换区域的大小取决于当前整数的逆序区域

1. 从后向前查看逆序区域，找到逆序区域的前一位，也就是数字置换边界
2. 让逆序区域的前一位和逆序区域中大于他的最小的数字交换位置
3. 把原来的逆序区域转为顺序状态

- 时间复杂度与空间复杂度均为O(n)

## 删除k个数字后的最小值

- 给一个整数，从该整数中去掉k个数字，要求剩下的数字尽可能小

### 解题思路

- 把原数字从左向右比较，如果发现某一位数字大于它右边的数字，那么在删除该数字后，必然会使数位的值降低
- 依次求得局部最优解，最终获得全局最优解的思想，叫贪心算法
- 可以用栈的方式来进一步对其优化

## 实现大整数相加

- 给两个特别大的整数，要求实现两数之和

### 解题思路

- 创建两个整型数组，数组长度为较大整数位数+1，把每个数组倒序装入数组中，也就是最高位存储于数组的尾部
- 创建结果数组，数组从左向右依次相加
- 如果结果数组最后一个是0则去掉这个0
- 也可以每隔n位进行切割，再依次相加

## 求解金矿问题（没看懂）

### 题目

- 5座金矿，每座金矿黄金储备不同，需要参与挖掘的工人认数不同。例如500kg黄金需要5人挖掘，200kg黄金需要3人挖掘
- 所有的金矿，要么全挖，要不不挖，人数也需要全部投入
- 现在有5个金矿，总共10个工人，金矿1：200kg/3人；金矿2：300kg/4人，金矿3：350kg/3人，金矿4：400kg/5人，金矿5：500kg/5人

### 解题思路

- 这是一个典型的动态规划题目，与背包问题类似
- 假设一个金矿5必须挖，那么问题就分割成剩下四个金矿求最优解，比较剩下四个最优解和金矿5，是放弃金矿5还是选择最优解
- 把问题依次划分下去，直到划分为0个人0个金矿就到达了问题的边界
- 动态规划的要点：确定全局最优解和最优子结构之间的关系，以及问题的边界，数学上叫状态转移方程式；自底向上求解

## 寻找缺失的整数

- 在一个无序数组里有99个不重复的正整数，范围是1~100，维度缺少1个1~100中的整数，如何找出这个整数

### 解题思路

- 创建一个哈希表，key未1~100，遍历数组并添加至哈希表，剩下唯一没有value的值即为所朝找的值
- 从大到小排列，找到不相邻的两个数字即为缺失的数字
- 算出1~100的累加，依次减去每个值

### 问题扩展

- 范围1~100的无序数组，99个数字出现了偶数次，只有一个整数出现了奇数次，如何找到这个奇数次的数组

  #### 解题思路

- 遍历数组，从头开始每个数字都进行异或运算，相同的数字异或运算为0

- 遍历完数组之后剩下的即为奇数次的数字

### 问题扩展2

- 范围1~100的无序数组，99个数字出现了偶数次，只有俩个整数出现了奇数次，如何找到这个奇数次的数组

  #### 解题思路

  - 将所有的数字遍历进行异或运算，最终得到一个结果值
  - 根据这个二进制数最后一位（任意一位）可以把数组分成两组，相同的分为一组，不同的分为一组，每组都会只包含一个出现奇数次的数字
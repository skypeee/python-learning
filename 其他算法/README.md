<!--

 * @Author: skypeee
 * @LastEditors: skypeee
 * @Description: file content
 * @Date: 2019-08-29 10:27:43
 -->
# 其他算法

## 判断链表是否有环

### 方法一

- 首先从头节点开始，依次遍历单链表中的每一个节点

- 从头检查新节点之前的所有节点

- 用新节点和此之前所有节点作比较，如果发现相同则说明有环

- 假设节点数为n，则时间复杂度为O(n²)，空间复杂度为O(1)

### 方法二

- 创建于给以节点Id为Key的HashSet集合，用来存储曾经遍历过的节点

- 从头结点开始，依次遍历单链表中每一个节点

  - 每遍历一个节点，都用新节点与HashSet集合中存储的节点进行比较，如果有相同则有环，不存在则插入HashSet

- 假设节点数为n，时间复杂度为O(n)，空间复杂度为O(n)

### 方法三

- 创建两个指针指向头节点

- 进行循环，指针P1每次向后移动1个节点，P2每次向后移动2个节点

- 比较两个节点是否相同，如果相同则有环，否则继续循环

- 假设节点数为n，时间复杂度为O(n)，空间复杂度为O(1)

- 环长 = 每一次速度差 * 前进次数 = 前进次数

## 最小栈的实现

- 实现一个栈，该栈带有出栈（pop）、入栈（push）、取最小元素（getMin）3个方法。要保证这三分方法时间复杂度都是O(1)

### 思路

- 原有的栈为栈A，创建一个“备胎”栈，栈B

- 当第一个元素进入栈A时，让此元素也进入栈B，这个元素时当前栈A的最小值

- 每次新元素进入栈A时，先与当前最小值比较，如果小于最小值，则进入栈B，则栈B的栈顶元素即为栈A的最小值

- 每当有元素出战，如果出栈元素是栈A的最小值，栈B栈顶元素也出栈，此时b栈新栈顶元素也成为了栈A的最小值（备胎转正）

- 获取最小值元素getMin就是获取栈B的栈顶元素

- 进栈、出栈、活取最小值时间复杂度都是O(1)，最坏空间复杂度是O(n)

## 最大公约数

### 辗转相除法（欧几里得算法）

- 两个正整数a和b（a>b），他们的最大公约数等于a除以b的余数c和b之间的最大公约数

### 更相减损法

- 两个正整数a和b（a>b），他们的最大公约数等于a-b的差值c和较小数b的最大公约数

### 结合

- 把辗转相除法与更相减损法的优势结合起来，在更相减损法的基础上使用移位运算

  - 获得最大公约数的方法getGreatestCommomDivisor简写为gcd

- 当a和b均为偶数时，gcd(a,b) = 2 *gcd(a/2, b/2) = 2* gcd(a>>1, b>>1)

- 当a为偶数，b为奇数时，gcd(a,b) = gcd(a/2,b) = gcd(a>>1,b)

- 当a为奇数时，b为偶数，gcd(a,b) = gcd(a,b/2) = gcd(a,b>>1)

- 当a和b均为奇数时，先利用更相减损法运算一次，gcd(a,b) = gcd(b,a-b)，此时a-b必为偶数，然后又可以继续进行移位运算

### 复杂度

- 暴力枚举法：时间复杂度时O(min(a,b))

- 辗转相除法：时间复杂度近似为O(log(max(a,b))),但是取模运算性能较差

- 更相减损法：避免了取模运算，但算法不太稳定，最坏时间复杂度为O(max(a,b))

- 更相减损法和移位相结合：避免了取模运算，算法稳定，时间复杂度为O(log(max(a,b)))

## 判断一个数是否为2的整数次幂

### 思路

- 是2的整数次幂的特点为该数转化为二进制，只有最高位是1，其余位都是0

- 因此该数字减1，所有的位数都为1

- 0和1按位运算的结果是0，饭十2的整数次幂和他本身减一的结果按位运算结果必然是0

## 无序数组排序后的最大相邻数

- 有一个无序整型数组，如何求出该数组排序后的任意两个相邻元素的最大差值（不进行排序）

### 解题思路1

- 利用计数排序的思想，先求出原数组的最大值与最小值的区间长度k=max-min+1以及位偏移量d=min
- 创建一个长度为k的新数组Array
- 遍历原数组，每遍历一个元素，就把新数组Array对应下标的值+1
- 遍历新数组，统计出Array中最大连续出现0的次数，即为相邻元素的最大差值

### 解题思路2

- 利用桶排序的思想，求出原数组长度n，分为n个桶，每个桶代表一个区间，区间跨度为（max/min）/（n-1）
- 遍历原数组，把原数组的元素一一插入对应的桶中，记录每个桶的最大值和最小值
- 遍历所有的桶，统计出每一个桶的最大值，和这个桶右侧非空桶的最小值的查，数值最大的查即为原数组排序后的相邻最大差值
- 时间复杂度稳定，为O(n)

## 如何用栈来实现队列

- 用栈来模拟，入队，出队

### 解题思路

- 创建两个栈一个栈最为队列的入口，负责插入新数据，一个栈作为队列的出口，移除老元素
- 入队时，每一个元素都压入栈A
- 出队时，将栈A中所有元素一一压入栈B，再通过栈B进行出栈
- 再次入队时，将栈B的元素一一压入栈A中，再通过栈A进行入队

## 寻找全排列的下一个数

### 题目

- 给出一个正整数，找出这个正整数所有数字全排列的下一个数
- 如果输入12345，返回12354
- 如果输入12354，返回12435
- 如果输入12435，返回12453

### 解题思路（字典序算法）

- 和原数接近，尽量保持高位不变，低位在最小范围内变换顺序
- 变换区域的大小取决于当前整数的逆序区域

1. 从后向前查看逆序区域，找到逆序区域的前一位，也就是数字置换边界
2. 让逆序区域的前一位和逆序区域中大于他的最小的数字交换位置
3. 把原来的逆序区域转为顺序状态

- 时间复杂度与空间复杂度均为O(n)

## 删除k个数字后的最小值

- 给一个整数，从该整数中去掉k个数字，要求剩下的数字尽可能小

### 解题思路

- 把原数字从左向右比较，如果发现某一位数字大于它右边的数字，那么在删除该数字后，必然会使数位的值降低
- 依次求得局部最优解，最终获得全局最优解的思想，叫贪心算法
- 可以用栈的方式来进一步对其优化

## 实现大整数相加

- 给两个特别大的整数，要求实现两数之和

### 解题思路

- 创建两个整型数组，数组长度为较大整数位数+1，把每个数组倒序装入数组中，也就是最高位存储于数组的尾部
- 创建结果数组，数组从左向右依次相加
- 如果结果数组最后一个是0则去掉这个0
- 也可以每隔n位进行切割，再依次相加

## 求解金矿问题（没看懂）

### 题目

- 5座金矿，每座金矿黄金储备不同，需要参与挖掘的工人认数不同。例如500kg黄金需要5人挖掘，200kg黄金需要3人挖掘
- 所有的金矿，要么全挖，要不不挖，人数也需要全部投入
- 现在有5个金矿，总共10个工人，金矿1：200kg/3人；金矿2：300kg/4人，金矿3：350kg/3人，金矿4：400kg/5人，金矿5：500kg/5人

### 解题思路

- 这是一个典型的动态规划题目，与背包问题类似
- 假设一个金矿5必须挖，那么问题就分割成剩下四个金矿求最优解，比较剩下四个最优解和金矿5，是放弃金矿5还是选择最优解
- 把问题依次划分下去，直到划分为0个人0个金矿就到达了问题的边界
- 动态规划的要点：确定全局最优解和最优子结构之间的关系，以及问题的边界，数学上叫状态转移方程式；自底向上求解

## 寻找缺失的整数

- 在一个无序数组里有99个不重复的正整数，范围是1~100，维度缺少1个1~100中的整数，如何找出这个整数

### 解题思路

- 创建一个哈希表，key未1~100，遍历数组并添加至哈希表，剩下唯一没有value的值即为所朝找的值
- 从大到小排列，找到不相邻的两个数字即为缺失的数字
- 算出1~100的累加，依次减去每个值

### 问题扩展

- 范围1~100的无序数组，99个数字出现了偶数次，只有一个整数出现了奇数次，如何找到这个奇数次的数组

  #### 解题思路

- 遍历数组，从头开始每个数字都进行异或运算，相同的数字异或运算为0

- 遍历完数组之后剩下的即为奇数次的数字

### 问题扩展2

- 范围1~100的无序数组，99个数字出现了偶数次，只有俩个整数出现了奇数次，如何找到这个奇数次的数组

  #### 解题思路

  - 将所有的数字遍历进行异或运算，最终得到一个结果值
  - 根据这个二进制数最后一位（任意一位）可以把数组分成两组，相同的分为一组，不同的分为一组，每组都会只包含一个出现奇数次的数字

## LRU（最近最早使用）算法

- 是一种n内存管理算法，该算法最早用于Linux系统
- 该算法基于一种假设：长期不被使用的数据，在未来被用到的纪律也不大，因此当数据所占内存达到一定阙值时，我们需要移除掉最近最少被使用的数据
- 在LRU算法中，使用了一种有趣的数据结构，这种数据结构叫做哈希链表
  - 哈希链表是若干个key-value序列构成的
  - 这些key-value被一条链条串了起来，每个key-value都具有他的前驱和后继key-value，像双向链表中的节点一样
- redis底层也使用了LRU算法

### 思路

1. 假设使用哈希链表来缓存用户，目前缓存了4个用户，这4个用户是按照被访问的时间顺序依次从链表右段插入的

2. 如果这时业务方访问用户5，由于哈希链表中没有用户5的数据，需要从数据库中读取出来，插入到缓存中。此时，链表左右端是最新被访问的用户5，最左端是最近最少被访问的用户1
3. 接下来，如果业务方访问用户2，哈希链表中已经存在了用户2的数据，这时我们把用户2从他的前驱节点和后继节点中删除，重新插入到链表的最右端，此时，链表的最右端变成了最新被访问的用户2，最左端仍然是最近最少被访问的用户1
4. 接下来，如果业务方请求修改用户4的信息。同理，我们会把用户4从原来的位置移动到链表的最右侧，并把用户信息的值更新。这时，链表的最右端是最新被访问的用户4，最右端仍然是最近最少被访问的用户1
5. 后来业务方又要访问用户6，用户6在缓存中没有，需要插入哈希链表中，假设此时缓存容量已经达到上限，必须先删除最近最少被访问的数据，那么位于哈希链表最左端的用户1就会被删除，然后再把用户6插入到最右端的位置

## A星寻路算法

### 思路

- 在解决问题之前，我们需要两个集合：OpenList可到达的格子，CloseList已到达的格子，还需要一个公式：  F = G + H
  - G：从起点走到当前格子的成本，也就是已经花了多少步
  - H：在不考虑障碍的情况下，从当前格子走到目标格子的距离，也就是离目标还要多远
  - F：G和H的综合评估，也就是从起点到达当前格子，再从当前格子到达目标格子的总步数
- 第一轮A星寻路
  1. 把起点放入OpenList，也就是刚才所说的可到达格子的集合
  2. 找出OpenList中F最小的方格最为当前方格，虽然我们没有直接计算起点方格的F值，但此时OpenList中只有唯一的方格Grid（1，2），把当前格子移出OpenList，放入CloseList。代表这个格子已到达并检查过了
  3. 找出当前方格（刚刚检查过的格子）上、下、左、右所有可到达的格子，看它们是否在OpenList或CloseList当中。如果他不在，则将他们加入OpenList，计算出相应的G、H、F值，并把当前格子作为他们的“父节点”
- 下面进入A星寻路的第二轮操作
  1. 找出OpenList中F值最小的方格  ，即方格Grid（2，2），将它作为当前的方格，并把当前方格移出OpenList，放入CloseList代表这个格子已经到达并检查过了
  2. 找出当前方格上、下、左、右所有可到达的格子，看他们是否在OpenList或CloseList当中。如果不在，则将他们加入OpenList，计算出相应的G、H、F值，并把当前格子作为他们的“父节点”

- 下面进入第三轮操作
  1. 找出OpenList中F值最小的方格，假如此时有多个方格的F值相等，任意选择一个即可，并且把当前方格移出OpenList，放入CloseList。代表这个格子已经到达并检查过了
  2. 找出当前方格上、下、左、右所有可到达的格子，看他们是否在OpenList当中，如果不在，将它们加入OpenList，计算出相应的G、H、F值，并把当前各自作为他们的“父节点”
- 剩下以前面的方式继续迭代，知道OpenList出现终点方格为止
- 最后顺着终点方格找到它的父亲、再找父亲的父亲依次回溯，就找到了一条最佳路径
- 像这种以估值高低来决定搜索优先次序的方法，被称为启发式搜索


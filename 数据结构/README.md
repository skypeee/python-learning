<!--
 * @Author: skypeee
 * @LastEditors: skypeee
 * @Description: file content
 * @Date: 2019-08-28 11:20:21
 -->

# 数据结构

- Data structure 是数据的组织、管理和存储格式
- 目的：为了高效地访问和修改数据

# 算法

- 一系列程序指令，用于处理特定的运算和逻辑问题

# 时间复杂度

- 简单来说就是代码运行时间或者说代码运行次数

- 吃一个n cm的面包，每3分钟吃1cm，吃完需要的时间为T(n)=3n，此时执行次数为线性，时间复杂度为T(n)=O(n)
  - PS：最高项为3n，省去系数3
- 长度为n cm的面包，每五分钟吃掉面包的一半，面包吃剩下1cm需要的时间T(n)=5log n，此时执行次数为对数，此时的时间复杂度为T(n)=O(log n)
  - PS：最高项为5log n，省去系数5
- 长度为n cm的面包和一个鸡腿，每两分钟吃掉一个鸡腿，吃掉一个鸡腿的时间T(n)=2，此时执行次数为常量，此时的时间复杂度为T(n)=O(1)
  - PS：省去系数2
- 长度为n cm的面包，吃掉第一个1cm需要1分钟，吃掉第二个1cm需要2分钟。。。。。。吃掉整个面包需要的时间T(n)=0.5n²+0.5n，此时执行次数为多项式运算，此时的时间复杂度为T(n)= O(n²)
- O(1) < O(log n) < O(n) < O(n²)

# 空间复杂度

- 在运行过程中临时占用存储空间大小的量度，同样适用O来表示
- 常量空间：O(1) 存储空间大小固定
- 线性空间：O(n) 集合大小和输入规模成正比
- 二维 空间：O(n²) 集合的长度和宽度和输入的规模均成正比
- 递归空间：如果递归的深度为n，则空间复杂度就是O(n)
- 时间复杂度与空间复杂度有时鱼和熊掌不可兼得，需要具体问题看需要牺牲哪一个。

# 线性结构

- 数组、链表、以及由他们衍生出来的栈、队列、哈希表

## 数组

- 像军队一样整齐、有序

- 在内存中顺序存储，因此可以很好的实现逻辑上的顺序表

### 基本操作

- 读取元素

  - 通过下标读取的方式叫做随机读取

  - 时间复杂度为O(1)

- 更新元素

  - 将数组中某一个值替换成一个新值

  - 时间复杂度为O(1)

- 插入元素
  - 尾部插入
    - 直接把数据插入尾部空闲位置
  - 中间插入
    - 把插入位置之后的元素向后移，腾出地方，再把要插入的元素放到插入位置
  - 超范围插入
    - 此时会执行数组扩容，创建一个长度为初始数组长度二倍的数组空间，将数据复制进去在进行插入
  - 扩容的时间复杂度为O(n)，插入并移动的时间复杂度为O(n)，因此综合时间复杂度也为O(n)
  - 删除元素
    - 先将删除位置元素删除，再将其后的元素前移
    - 删除时间复杂度也为O(n)

### 优点：高效的随机访问（通过下标，通过常量时间就可访问）

### 缺点：插入和删除由于大量数据移动，影响效率

### 数组适合读操作多、写操作少的场景

## 链表

- 数组像正规军，而链表像地下党，每个人只知道上下级是谁

- 物理上非连续、非顺序存储，有若干个节点组成，在内存上随即存储

- 只要空间允许，链表不需要考虑扩容，可以一直增加元素

### 类型

- 单向列表
  - data，存放数据的变量
  - next，存放下一个节点的指针
- 双向列表
  - data，存放数据的变量
  - next，存放下一个节点的指针
  - prev，存放上一个节点的指针

### 基本操作

- 查找节点
  - 只能从头一个一个节点逐步向后查找
  - 链表中的节点只能顺序访问，最坏的时间复杂度为O(n)
- 更新节点
  - 直接将旧数据替换成新数据
  - 不考虑之前的寻找节点时间复杂度为O(1)
- 插入节点
  - 尾部插入
    - 在最后一个节点的next指向新的节点
  - 中间插入
    - 新节点的next指向插入位置的节点
    - 插入位置的前置节点的next指向新节点
  - 头部插入
    - 把新节点的next指向原来的头结点
    - 将新节点的变为链表的头结点
    - 不考虑之前的寻找时间复杂度为O(1)
- 删除节点
  - 尾部删除
    - 把倒数第二个节点的next指向空
  - 头部删除
    - 把头部节点设置为原先头部节点的next值
  - 中间删除
    - 将删除节点的前置节点的next指针指向删除节点的next
    - 不考虑之前的寻找节点时间复杂度为O(1)
    - PS：Java、Python等高级语言拥有自动化垃圾回收机制，不需要我们手动释放空间

## 数组与链表的对比

| 查找 | 更新 | 插入 |删除
-|-|-|-|-
| 数组 | O(1) | O(1) | O(n) | O(n)
| 链表 | O(n) | O(1) | O(1) | O(1)

- 表格可以快速定位元素，对于读操作多，写操作少的场景更适合
- 链表可以灵活插入，对经常在首尾插入删除元素的场景更加适合

- 链表与数组属于物理结构
- 栈和队列属于逻辑结构

## 栈

- 像一个乒乓球桶
- 特点：先进后出（First In Last Out，简称FILO）
- 栈底：最早进入的元素存放的位置
- 栈顶：最后进入的元素存放的位置

### 基本操作

- 入栈（Push）
  - 只允许从栈顶一侧放入元素
  - 新元素的位置将会成为新的栈顶
  - 时间复杂度O(1)
- 出栈（Pop）
  - 把元素从栈中弹出
  - 只允许从栈顶一侧出栈
  - 出栈元素的前一个元素会成为新的栈顶
  - 时间复杂度O(1)

### 应用

- 面包屑导航栏可以返回上一级

## 队列

- 像车进入隧道
- 特点：先进先出（First In First Out，简称FIFO）
- 队头：队列的出口端
- 队尾：队列的入口端
- PS：用数组实现时，队尾是最后一个元素的下一个位置

### 基本操作

- 入队
  - 新元素放到队尾
  - 新元素的下一个位置成为新队尾
  - 时间复杂度O(1)
- 出队
  - 把元素从队头移除
  - 后一个元素会成为新的队头
  - 时间复杂度O(1)

### 应用

- 多线程，争夺公平锁就是按照队列的次序来的
- 网络爬虫爬取顺序也是按照队列来进行的

#### 双端队列

- 栈和队列的特点结合起来，既可以先进先出，也可以先进后出

#### 优先队列

- 谁优先级高谁出队
- 通过二叉堆来实现

#### 循环队列

- 如果不断出队，会导致容量越来越小
- 在队列不扩容的前提下，最大化使用空间
- 实现
  - 如果队尾到了数组的末端，下一次入队时，队尾指向数组的初始位置
  - 队满条件：（队尾下标+1）%数组长度==队头下标
  - 尾位置永远空出1个，因此队列最大容量比数组容量小1

## 散列表

- 像字典一样，输入Apple，查询苹果
- 散列表也叫哈希表
- 提供Key-Value键值对的映射关系
- 查询时间复杂度接近O(1)，非常高效

### 哈希函数

- 像中转站一样，将key和数组下标进行转换
- 在大多数面向对象语言中，每一个对象都有属于自己的hashcode，无论类型是什么，hashcode都是一个整形变量
- 当插入的值越来越多，而且不同的键通过哈希函数出来的值可能相同，因此会出现哈希冲突
- 开放寻址
  - 当哈希出来的key非空时往后找，找到第一个部位空的值放进去（不一定是往后找）
- 链表法
  - 当前位置非空时，此对象的next指针指向新值

### 基本操作

- 写操作（插入（"002931"，"王五"））
  - 通过哈希函数，将002931转化成5
  - 将王五这个值插入到key为5的位置
- 读操作
  - 通过指定key值读取value
  - 哈希冲突的话，按照对应的算法一直找，直到找到位置的key值与查询的key相等时，取出values值
  - 扩容
    1. 创建一个新的数组，长度是原长度的二倍
    2. 重新哈希（扩容后哈希规则也会改变）

## 树

- 二叉树、及衍生出来的各种树

### 定义

- 有且仅有一个特定的称为根的节点
- 其余节点可以分为m个不相交的有限集，每一个集合也是一个树（根的子树）

### 二叉树

- 每个节点最多有两个孩子节点，一个为左子树，一个为右子树
- 满二叉树：此树非叶子节点都存在左子树和右子树
- 完全二叉树：满二叉树从右到左的顺序删除节点

#### 存储方式

- 链式存储结构
  - Data 存放数据
  - Left 存放左子树指针
  - Right 存放右子树指针
- 数组
  - 父节点的下标是parent，左子树下标就为2×parent+1，右子树下标2×parent+2
  - 左子树下标为leftchild，父节点下标就为（leftchild-1）/2

#### 应用

##### 二叉查找树（二叉排序树）

- 条件
  - 如果左子树不为空，则左子树上所有节点的值均小于根节点的值
  - 如果右子树不为空，则右子树上所有节点的值均大于根节点的值
  - 左右子树也都是二叉查找树
  - 对于一个节点分布相对均匀的二叉查找树来说，如果节点总数是n，那么搜索节点的时间复杂度是O(log n)，和树的深度是一样的
- 自平衡
  - 红黑树
  - AVL树
  - 树堆
- 二叉树的遍历
  - 深度优先遍历（栈与递归的方式）
    - 前序遍历
      - 输出顺序：根节点、左子树、右子树
    - 中序遍历
      - 输出顺序：左子树、根节点、右子树
    - 后序遍历
      - 输出顺序：左子树、右子树、根节点
- 广度优先遍历
  - 层序遍历（队列）
- 二叉堆（数组下标实现）
  - 本质上是完全二叉树
  - 类型
    - 最大堆
      - 任何一个父节点的值都大于或等于他的左右孩子节点的值
      - 二叉堆的根节点叫做堆顶
      - 堆顶是整个堆的最大元素
    - 最小堆
      - 堆顶是整个堆的最小元素
      - 自我调整
  - 插入节点
    - 插入的位置是完全二叉树的最后一个位置（最小堆）新节点比父节点小的话不符合最小堆，于是进行“上浮”（替换）
    - 继续用新节点与替换过的位置的父节点比较，继续上浮
    - 时间复杂度O(log n)
  - 删除节点
    - 如果删除了堆顶的节点
    - 为了维持二叉树结构，把堆的最后一个节点临时补充到原堆顶的位置
    - 然后与左右孩子中最小的一个进行“下沉”
    - 继续往下比较
    - 时间复杂度O(log n)
  - 构建二叉堆
    - 从最后一个非叶子节点开始比较进行“上浮”
    - 时间复杂度O(n)

## 图

- 多对多的关联关系

## 其他数据结构
